[TOC]



# 一篇文章彻底搞懂TCP协议

注：本文的TCP报文段，分组，包是一个意思。

tcp协议全称**Transmission Control Protocol**，传输控制协议。

主要解决三个问题：

- **不可靠信道的可靠传输问题**
- **流量控制问题**
- **拥塞控制问题**

## 可靠传输问题

可靠传输问题可以用**等待应答**和**超时重传**解决

### 等待应答

等待应答即发送方每发送一个包，都期待收到一个对应的应答包，如果收到应答包，则保证了接收方一定收到了包，通信具有“可靠性”。接收方每收到一个包，都会发送回一个应答包。

等待应答引入了一个问题：**如果当前包没有收到应答，能否发送下一个包？**

- 如果不能发送，发送方只需要简单在等待上层调用和等待应答两个状态间切换，接收方只需要收到数据之后立即上传，不需要缓存区，这属于停等协议，效率低下，一个RTT只能发送一个分组。
- 如果可以发送，则通信对象需要同时处理多个分组，就需要给每个分组提供**序号**以互相区分，使用**确认号**表明应答哪些分组，给发送方提供缓存空间以存储已发送未应答的分组，因为这些分组有可能需要重传。

真实网络肯定使用第二种。顺便说一句，由于TCP协议的通信对象需要像序号，确认号这样的信息来控制分组，所以每个TCP报文段都分为**TCP头部**和**TCP数据段**，头部用来放传输该分组所需要的控制信息，数据段是我们真正希望发送的信息。

可以看到第二种方式使得发送方和接收方的事件响应逻辑变得复杂起来。

实际上如果只保证可靠传输，可以有多种设计方式，这里我们只看现代TCP一般是怎么做的。

序号表示该分组在该次连接（TCP是**面向连接**的，后面会讲连接）的数据流当中的位置，TCP的确认号表示“这个号码指出的序号之前的包我都收到了，下一个包我希望收到这个序号”，注意，确认号的含义不是单指”这个序号的包我收到了“，而是”这个号码之前的包我都收到了“，这种确认机制叫做**累积确认**。一个确认号确认一个包，这种确认机制叫做**选择确认**，这种方式理论上也可行，在发送方和接收方的设计上有所区别，但是目前的TCP采用的是**累积确认**。

发送方和接收方都有一个最基本的“滑动窗口”。

发送方窗口的最左侧是序号最小的已发送但未确认的分组。

接收方窗口的最左侧是“希望收到的下一个序号”，没错，其实就是发送的确认号。

发送方和接收方需要时刻维护这个窗口。每当发送方收到了确认，就需要尝试将窗口右移，移动到确认号的位置。每当接收方收到包，也需要尝试将窗口右移，如果说收到的包的序号恰好是“希望收到的下一个序号”，那么窗口可以右移，如果说收到的包的序号大于“希望收到的下一个序号”，由于我们使用累积确认，能够发送的确认号是不能变的，（仔细考虑一下，由于跳过了一些包没有收到，能够自信满满地说“这个序号前面的包我都收到了”的这种号码并没有变化）窗口就无法移动，接收方会将这个包缓存下来，但是应用无法读取。无论窗口是否移动，接收方最后是一定会发送一个确认号回去的，这个确认号就是窗口的最左侧。因此发送方很有可能连续多次收到相同的确认号，所以我们才说发送方也只是尝试将窗口右移，而不是一定会右移，连续多次收到相同确认号是无法右移的。

这里你可能会问：**为什么发送方按顺序发送包，后面发送的包却会先到达接收方呢？**

这里的原因有两个：

- 在网络中，即使是同一次连接发送的相邻两个分组，路径仍然可能不同，因此先发送的包后到达是很正常的事情。
- 先发送的包丢失了。

其实这里说的两个原因是一个原因：网络过于复杂，链路“不可靠”，不确定性很大，因此任何一个包的时延或丢失情况都是不确定的。

当发送方连续三次收到相同确认号，释放了一个强烈的信号：这个序号的分组很有可能丢失了，以至于接收方一直在重复“我希望收到这个序号的分组，我希望收到这个序号的分组······"，这会启动**快速重传**例程，之后我们会和拥塞控制问题一起说，现在只需要知道，发送方通过收到的确认号的情况，能够判断出哪些包需要重传。因此，发送方和接收方的窗口能够有条不紊地持续右移，直到所有的数据都被发送完。

### 超时重传

超时重传有两个问题：

**时间间隔应该如何确定**？

直觉告诉我们，这个时间间隔应该比RTT（往返时间）稍微长一点，但是不能长太多。如果比RTT短，所有的包都必然超时，如果比RTT长太多，发送方对于丢包的反应就太迟钝了。

实际上使用了采样往返时间SampleRTT累积平均得到估计往返时间EstimatedRTT，然后计算SampleRTT和EstimatedRTT之间的偏差的程度，用Estimated加上一定比例的偏差值就可以了。具体的公式不用记，记住比RTT多一点以及是实时调整的就可以了。

**怎么计时？重传哪些分组？**

- 为最早发送的未确认包计时，即发送窗口最左侧的包
- 这个”计时“操作是一个逻辑操作，不是真实的操作，真实的实现使用的是保存窗口内包的发送时间戳，设置单一定时器到期时间的方式
- 重传也仅仅是这一个分组

## 流量控制问题

流量控制问题指的是防止接收方缓存溢出的问题。

刚才我们讨论滑动窗口的时候，其实在假设缓存空间无限大。

接收方的剩余缓存空间是由接收方收到数据的速率和应用层读取速率共同决定的。如果收到数据的速率比应用层读取速率快，接收方缓存中的包会越来越多，直到放不下。

一方面，应用层根据自己的需要读取数据，本身有一个速率。

另一方面，应用层只能按顺序读取收到的包，对于失序但缓存的包，是不能读取的。

解决这个问题的方式是：

发送方维护一个称为**接收窗口**的变量来提供流量控制，只要发送的数据在接收窗口内，就可以保证接收方的缓存不溢出。

接收窗口应该设置成多大？当然是接受方的剩余缓存空间大小。而这个数会放在应答包的TCP头部的窗口大小字段中。

每当接收方收到一个包，都会计算当前剩余缓存空间大小，放入应答包当中。

这里可能会出现一种极端情况，接收方在短时间内收到大量包，将存储空间填满，最后一个应答包发送的窗口大小为0，这时理论上发送方将不能再发送任何新的数据包（但是可以重传），任何新的数据包都可能会导致接收方缓存溢出。

但是，如果不能再发送包，又没有需要重传的包的话，也就不会再收到应答包，窗口大小就不能更新，通信就此卡住。

所以这个时候发送方会定时发送一个一字节的**窗口探测**包。

这个包会被接收方确认，目的就是收到一个新的窗口大小，使通信得以继续。

从通信连接开始，接收方就不停向发送方告知自己还有多少剩余空间，最开始剩余空间大小刚好等于缓存空间大小，即使发送方一股脑将窗口内数据全部发送出去，接收方瞬间收到所有数据并且缓存，也只是恰好把缓存空间占满，而不会溢出。在收到下一个应答包更新窗口大小之前，剩余缓存空间只会因为应用层的读取而变得更大，而不会因为收到新的数据变得更小（因为我们已经假设发送方的所有数据都瞬间到达了接收方），这就是流量控制的原理。

## 拥塞控制问题

拥塞控制问题是指在遇到网络拥塞的时候如何遏制发送方，以**提升全网稳定性**。注意区别流量控制和拥塞控制，虽然都是遏制发送方的发送速率，而且都是用”窗口“这样的方式，但是二者的目的是截然不同的。

核心机制用一句话解释：**卡了就慢点发**。

大家都慢点发，网络就不卡了。

问题来了：**如何判断卡了？怎么慢点发？**

即，TCP发送方如何感知它到目的地之间的路径上存在拥塞？

TCP发送方如何限制它向其连接发送流量的速率？

先回答第二个问题，答案是使用**拥塞窗口**

我们保证发送方中未确认的数据量不会超过拥塞窗口的大小。

前面我们说发送方中未确认的数据量不会超过接收窗口的大小。所以，综合起来，发送方中未确认的数据量不会超过拥塞窗口大小和接收窗口大小中的最小值。

然后回答第一个问题，答案是：丢包意味着拥塞，收到确认意味着不拥塞。

所以，在TCP的拥塞控制算法中，丢包会减小拥塞窗口，收到确认会增加拥塞窗口，下面我们看具体的TCP拥塞控制算法。

### TCP拥塞控制算法

首先分为三种状态：慢启动，拥塞避免，快速恢复

在三种在状态中，拥塞窗口的大小会以不同的速率增长。

三种状态会因为某些事件触发切换。

先规定一些变量的表示。cwnd表示用三个窗口大小。MSS表示TCP的最大报文长度，ssthresh表示慢启动阈值，单位都是字节，cwnd是MSS的整数倍。RTT表示往返时间。

#### 慢启动

慢启动状态是连接开始时的状态，cwnd被设置为一个MSS。

每收到一个确认，cwnd就增加一个MSS。

首先一次性发送一个MSS，约一个RTT后，收到一个确认，cwnd变为2个MSS，约一个RTT后，收到两个确认，cwnd变为4个MSS。可以看到，发送速率呈指数形式增长。

开始这种发送会很顺利，速率大到一定程度，就会出现超时丢包。一但出现超时丢包，TCP发送方会将cwnd设置成1个MSS，重新开始慢启动，同时将慢启动阈值设置为ssthresh=cwnd/2。

之后的慢启动过程，一但cwnd超过了ssthresh，将会切换为拥塞避免状态。

还有一种结束慢启动的事件：就是连续收到三个冗余ACK，就会执行快速重传并且切换为快速恢复状态。

#### 拥塞避免

每个RTT将cwnd增加一个MSS。

一但出现超时，将cwnd设置成1个MSS，重新开始慢启动，同时将慢启动阈值设置为ssthresh=cwnd/2。

一但连续收到三个冗余ACK，就会执行快速重传，将cwnd和ssthresh设置为原来的一半，cwnd再加上3个MSS，然后切换为快速恢复状态。

#### 快速恢复

每收到一个冗余ACK，cwnd的值增加一个MSS，已经收到的三个冗余ACK也算。

丢失报文段的ACK到达时，TCP降低cwnd后进入拥塞避免状态。

《计算机网络自顶向下方法》一书中的状态转移图完整说明了状态之间如何切换：

![image-20250918104848070](E:\Computer-Networking\计算机网络-自顶向下\详解TCP问答.assets\image-20250918104848070.png)

总结起来是这样的：

- 慢启动的cwnd一定从1开始指数增长
- 拥塞避免的cwnd一定从ssthresh开始线性增长
- 超时触发慢启动
- 到达ssthresh或快速恢复结束触发拥塞避免
- 三个冗余ACK触发快速恢复，收到丢失报文的ACK结束快速恢复，期间cwnd根据ACK数增长。
- 除了触发拥塞避免，别的状态切换都会使得ssthresh=cwnd/2

## TCP连接/断开过程

至此我们其实已经解释清楚了TCP要解决的三个问题。但是前面说过，TCP是面向连接的，这个我们还没有解释。

这里的连接是一个抽象的概念，我们希望，两个TCP通信对象应当先建立连接，然后收发数据，最后断开连接，这应当是一次通信的完整过程。

### 为什么要连接

有一个问题，为什么TCP要建立连接呢？为什么不像UDP那样直接收发数据，只需要每次收发数据的时候给出地址就可以了，也许你会说，就是因为懒得给每一条数据都标出地址，所以才需要连接。但是这肯定不是本质的原因，本质原因是TCP希望解决前面提到的三个问题，用到了序号和确认号这样的控制信息，而这些控制信息，只有在连接中才有意义。

我们说序号是分组在该次连接的数据流当中的位置，序号的定义就需要连接，因为序号总是需要一个起点。如果没有连接，序号就没有意义。

**连接是TCP在不可靠IP之上实现”可靠、顺序、流量控制、拥塞控制、全双工“所需的最小状态契约”**

### 建立连接过程---三次握手

假设一个客户端主机想要与服务端主机建立连接，过程如下：

- 客户端TCP向服务端TCP发送一个报文，这个报文不含数据段，但是头部的SYN字段为1，同时客户端随机选择一个初始序号client_isn，放入该报文头部的序号字段中。这里的SYN=1，表示“我想和你建立连接”。
- 服务端收到报文后，为这个连接分配TCO缓存和变量，发送回一个报文，SYN=1，表示“我也想和你建立连接”，确认号ack设置为client_isn +1，表示“我已经收到了这条报文”，服务端也会随机选择一个初始序号server_isn放入序号字段。这个报文称为SYNACK报文段
- 客户端收到SYNACK报文段之后，发送一个对该报文段的响应报文，这个报文的SYN比特被设置为0

之后客户端和服务器主机就可以收发数据了。

经常问到的一个问题是：**为什么一定要三次握手，为什么不是两次握手？**如果你不系统学习计算机网络，而是直接背八股文，很可能背到这个问题的答案，然后常常忘记。但是，这个问题的答案是不需要背的，如果你理解了TCP协议的核心功能是可靠数据传输，而且使用确认应答来保证可靠传输的话，就会发现三次握手是必要的：你感觉多出来的一次就是可靠数据传输所必需的确认应答。

所谓的建立连接其实也就是一种类似应用层的需求，需要传达“我想和你建立连接“这种信息，这里我们将这个信息整合到了TCP头部的SYN字段当中，但是传递这种信息仍然需要确认应答机制来保证可靠。所以客户端发送的第一条报文，需要服务端发送的第一条报文来确认应答，而服务端发送的第一条报文，需要客户端确认应答。

实际上，我认为需要四次握手而不是三次握手。

客户端发送请求连接，服务端确认应答，服务端发送同意连接，客户端确认应答。只不过服务端将确认应答“捎带”在同意连接的报文里了而已。

这种捎带是为了减少流量的优化手段，时时刻刻都在发生。我们在讨论可靠传输机制的时候，将通信双方分为一个发送方一个接收方，实际上，每个TCP通信对象都是平等的，既可以是发送方，又可以是接收方，接收方需要发送确认应答的包，这个包本来是不需要数据段的，称为纯ACK包，但是如果“接收方”这时恰好需要发送数据，那么，就可以将确认应答放在要发送数据的这个包之中，而不需要用纯ACK包。我们说这样的“应答”是捎带的。实际上，究竟是数据被捎带还是确认应答被捎带还有待讨论，从保证可靠传输的核心地位来看，确认应答是必要的，而数据什么时候发都可以，所以也可以认为这里的数据是捎带的。

为了实现捎带，需要一种实际使用的延迟确认应答。即收到数据之后不立即应答，而是延迟一段时间：

- 在没有收到2MSS的数据为止不做确认应答
- 其它情况下，最大延迟0.2秒发送确认应答。

这种机制可以提高网络利用率，降低计算机处理负荷，同时实现捎带应答。

### 断开连接---四次挥手

理解了三次握手也就理解了四次挥手。

- 客户端发送请求断开连接的报文，其中FIN=1，表示请求断开连接
- 服务端发送确认应答
- 服务端发送同意断开连接的报文，其中FIN=1，表示请求断开连接
- 客户端发送确认应答

实际上，如果服务端愿意立即断开连接，第二次和第三次也常常合并为一条报文。这样就变成了”三次挥手“

你可能会问，为什么断开连接还需要协议规定，直接停止发送不就好了。

但是我们需要区分正常的断开连接和异常的网络中断。四次挥手过程圆满完成，说明本次通信十分顺利，而如果是从某一个时刻开始忽然收不到信息，属于一方强制终止连接，或者异常终止，对于这两种情况，我们往往希望做出不同的反应。

就像我们和别人在线上聊天，直接忽然不聊了会显得有点不礼貌，而说一句”我有点事，先下了“，然后对方回复”好的” ，“拜拜“，然后你回复”拜拜“，这样这次聊天才算愉快地结束。